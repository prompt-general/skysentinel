import asyncio
from typing import Dict, List, Any, Optional
from datetime import datetime
import subprocess
import json

class SecurityTest:
    """Base class for security tests"""
    
    def __init__(self, name: str, category: str, severity: str):
        self.name = name
        self.category = category
        self.severity = severity
    
    async def run(self, target: Dict) -> Dict[str, Any]:
        """Run security test"""
        raise NotImplementedError

class NetworkSecurityTest(SecurityTest):
    """Network security tests"""
    
    async def run(self, target: Dict) -> Dict[str, Any]:
        """Run network security tests"""
        results = {
            "test": self.name,
            "category": self.category,
            "severity": self.severity,
            "timestamp": datetime.utcnow().isoformat(),
            "findings": []
        }
        
        # Test for open ports
        open_ports = await self.scan_ports(target["ip"])
        if open_ports:
            results["findings"].append({
                "issue": "Open ports detected",
                "details": open_ports,
                "severity": "HIGH",
                "recommendation": "Restrict access to necessary ports only"
            })
        
        # Test for SSL/TLS vulnerabilities
        ssl_issues = await self.test_ssl(target["hostname"])
        if ssl_issues:
            results["findings"].extend(ssl_issues)
        
        return results
    
    async def scan_ports(self, ip: str) -> List[int]:
        """Scan for open ports"""
        try:
            # Use nmap or similar tool
            cmd = ["nmap", "-T4", "-F", ip]
            result = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            stdout, stderr = await result.communicate()
            
            # Parse nmap output
            open_ports = []
            for line in stdout.decode().split("\n"):
                if "/tcp" in line and "open" in line:
                    port = line.split("/")[0]
                    open_ports.append(int(port))
            
            return open_ports
        except Exception as e:
            print(f"Port scan failed: {e}")
            return []
    
    async def test_ssl(self, hostname: str) -> List[Dict]:
        """Test SSL/TLS configuration"""
        try:
            cmd = ["testssl.sh", "--json", hostname]
            result = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            stdout, stderr = await result.communicate()
            
            findings = []
            if stdout:
                data = json.loads(stdout.decode())
                for vulnerability in data.get("vulnerabilities", []):
                    if vulnerability.get("severity") in ["HIGH", "CRITICAL"]:
                        findings.append({
                            "issue": vulnerability.get("id"),
                            "details": vulnerability.get("finding"),
                            "severity": vulnerability.get("severity"),
                            "recommendation": vulnerability.get("remediation", "")
                        })
            
            return findings
        except Exception as e:
            print(f"SSL test failed: {e}")
            return []

class APISecurityTest(SecurityTest):
    """API security tests"""
    
    async def run(self, target: Dict) -> Dict[str, Any]:
        """Run API security tests"""
        results = {
            "test": self.name,
            "category": self.category,
            "severity": self.severity,
            "timestamp": datetime.utcnow().isoformat(),
            "findings": []
        }
        
        # Test for SQL injection
        sql_injection = await self.test_sql_injection(target["endpoint"])
        if sql_injection:
            results["findings"].append(sql_injection)
        
        # Test for XSS
        xss = await self.test_xss(target["endpoint"])
        if xss:
            results["findings"].append(xss)
        
        # Test for broken authentication
        auth_issues = await self.test_authentication(target["endpoint"])
        if auth_issues:
            results["findings"].extend(auth_issues)
        
        return results
    
    async def test_sql_injection(self, endpoint: str) -> Optional[Dict]:
        """Test for SQL injection vulnerabilities"""
        # Implementation would use tools like sqlmap
        return None
    
    async def test_xss(self, endpoint: str) -> Optional[Dict]:
        """Test for XSS vulnerabilities"""
        # Implementation would use tools like XSStrike
        return None
    
    async def test_authentication(self, endpoint: str) -> List[Dict]:
        """Test authentication mechanisms"""
        findings = []
        
        # Test for default credentials
        default_creds = [
            ("admin", "admin"),
            ("admin", "password"),
            ("root", "root"),
            # ... more default credentials
        ]
        
        for username, password in default_creds:
            if await self.try_login(endpoint, username, password):
                findings.append({
                    "issue": "Default credentials found",
                    "details": f"Username: {username}, Password: {password}",
                    "severity": "CRITICAL",
                    "recommendation": "Change default credentials immediately"
                })
        
        # Test for weak password policy
        weak_passwords = ["123456", "password", "qwerty", "admin123"]
        for weak_pwd in weak_passwords:
            if await self.try_login(endpoint, "test", weak_pwd):
                findings.append({
                    "issue": "Weak password accepted",
                    "details": f"Password: {weak_pwd}",
                    "severity": "HIGH",
                    "recommendation": "Enforce strong password policy"
                })
        
        return findings

class ContainerSecurityTest(SecurityTest):
    """Container security tests"""
    
    async def run(self, target: Dict) -> Dict[str, Any]:
        """Run container security tests"""
        results = {
            "test": self.name,
            "category": self.category,
            "severity": self.severity,
            "timestamp": datetime.utcnow().isoformat(),
            "findings": []
        }
        
        # Scan container image for vulnerabilities
        vulnerabilities = await self.scan_container_image(target["image"])
        if vulnerabilities:
            results["findings"].extend(vulnerabilities)
        
        # Check container configuration
        config_issues = await self.check_container_config(target["container_id"])
        if config_issues:
            results["findings"].extend(config_issues)
        
        return results
    
    async def scan_container_image(self, image: str) -> List[Dict]:
        """Scan container image for vulnerabilities"""
        try:
            # Use trivy or similar tool
            cmd = ["trivy", "image", "--format", "json", image]
            result = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            stdout, stderr = await result.communicate()
            
            findings = []
            if stdout:
                data = json.loads(stdout.decode())
                for result in data.get("Results", []):
                    for vulnerability in result.get("Vulnerabilities", []):
                        if vulnerability.get("Severity") in ["HIGH", "CRITICAL"]:
                            findings.append({
                                "issue": vulnerability.get("VulnerabilityID"),
                                "details": vulnerability.get("Title", ""),
                                "severity": vulnerability.get("Severity"),
                                "recommendation": f"Update to {vulnerability.get('FixedVersion', 'latest')}"
                            })
            
            return findings
        except Exception as e:
            print(f"Container scan failed: {e}")
            return []
    
    async def check_container_config(self, container_id: str) -> List[Dict]:
        """Check container configuration security"""
        findings = []
        
        # Check if running as root
        cmd = ["docker", "inspect", "--format", "{{.Config.User}}", container_id]
        result = subprocess.run(cmd, capture_output=True, text=True)
        if result.stdout.strip() == "" or result.stdout.strip() == "0":
            findings.append({
                "issue": "Container running as root",
                "details": "Container is running with root privileges",
                "severity": "HIGH",
                "recommendation": "Run container as non-root user"
            })
        
        # Check for privileged mode
        cmd = ["docker", "inspect", "--format", "{{.HostConfig.Privileged}}", container_id]
        result = subprocess.run(cmd, capture_output=True, text=True)
        if result.stdout.strip() == "true":
            findings.append({
                "issue": "Container running in privileged mode",
                "details": "Container has full host access",
                "severity": "CRITICAL",
                "recommendation": "Disable privileged mode"
            })
        
        return findings

class PenetrationTestingFramework:
    """Main penetration testing framework"""
    
    def __init__(self):
        self.tests = [
            NetworkSecurityTest("Network Scan", "network", "HIGH"),
            APISecurityTest("API Security", "api", "HIGH"),
            ContainerSecurityTest("Container Security", "container", "HIGH")
        ]
    
    async def run_full_assessment(self, target: Dict) -> Dict[str, Any]:
        """Run full penetration test assessment"""
        results = {
            "target": target,
            "start_time": datetime.utcnow().isoformat(),
            "tests": [],
            "summary": {
                "total_tests": 0,
                "tests_passed": 0,
                "tests_failed": 0,
                "findings": {
                    "CRITICAL": 0,
                    "HIGH": 0,
                    "MEDIUM": 0,
                    "LOW": 0
                }
            }
        }
        
        # Run all tests concurrently
        tasks = [test.run(target) for test in self.tests]
        test_results = await asyncio.gather(*tasks)
        
        results["tests"] = test_results
        results["summary"]["total_tests"] = len(test_results)
        
        # Aggregate findings
        for test_result in test_results:
            if not test_result.get("findings"):
                results["summary"]["tests_passed"] += 1
            else:
                results["summary"]["tests_failed"] += 1
            
            for finding in test_result.get("findings", []):
                severity = finding.get("severity", "LOW")
                results["summary"]["findings"][severity] += 1
        
        results["end_time"] = datetime.utcnow().isoformat()
        results["duration"] = (
            datetime.fromisoformat(results["end_time"]) - 
            datetime.fromisoformat(results["start_time"])
        ).total_seconds()
        
        # Generate risk score
        risk_score = self._calculate_risk_score(results["summary"]["findings"])
        results["risk_score"] = risk_score
        
        # Generate recommendations
        results["recommendations"] = self._generate_recommendations(test_results)
        
        return results
    
    def _calculate_risk_score(self, findings: Dict[str, int]) -> float:
        """Calculate overall risk score"""
        weights = {
            "CRITICAL": 10,
            "HIGH": 7,
            "MEDIUM": 4,
            "LOW": 1
        }
        
        total_score = 0
        for severity, count in findings.items():
            total_score += weights.get(severity, 1) * count
        
        # Normalize to 0-100
        max_possible = sum(weights.values()) * 10  # Assume max 10 findings per severity
        risk_score = (total_score / max_possible) * 100 if max_possible > 0 else 0
        
        return min(risk_score, 100)
    
    def _generate_recommendations(self, test_results: List[Dict]) -> List[Dict]:
        """Generate prioritized recommendations"""
        recommendations = []
        
        for test_result in test_results:
            for finding in test_result.get("findings", []):
                recommendations.append({
                    "test": test_result["test"],
                    "issue": finding["issue"],
                    "severity": finding["severity"],
                    "recommendation": finding["recommendation"],
                    "category": test_result["category"]
                })
        
        # Sort by severity
        severity_order = {"CRITICAL": 0, "HIGH": 1, "MEDIUM": 2, "LOW": 3}
        recommendations.sort(key=lambda x: severity_order.get(x["severity"], 4))
        
        return recommendations
