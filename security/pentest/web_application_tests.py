import asyncio
from typing import Dict, List, Any, Optional
from datetime import datetime
import requests
from urllib.parse import urljoin
import re

class WebApplicationTest:
    """Web application security tests"""
    
    def __init__(self, name: str, category: str, severity: str):
        self.name = name
        self.category = category
        self.severity = severity
    
    async def run(self, target: Dict) -> Dict[str, Any]:
        """Run web application security test"""
        results = {
            "test": self.name,
            "category": self.category,
            "severity": self.severity,
            "timestamp": datetime.utcnow().isoformat(),
            "findings": []
        }
        
        # Test for OWASP Top 10 vulnerabilities
        owasp_tests = [
            self.test_broken_access_control,
            self.test_cryptographic_failures,
            self.test_injection,
            self.test_insecure_design,
            self.test_security_misconfiguration,
            self.test_vulnerable_components,
            self.test_identification_authentication,
            self.test_software_data_integrity,
            self.test_logging_monitoring,
            test_ssrf
        ]
        
        for test_func in owasp_tests:
            try:
                test_results = await test_func(target)
                if test_results:
                    results["findings"].extend(test_results)
            except Exception as e:
                print(f"Test {test_func.__name__} failed: {e}")
        
        return results
    
    async def test_broken_access_control(self, target: Dict) -> List[Dict]:
        """Test for broken access control (A01)"""
        findings = []
        
        # Test for missing authentication on sensitive endpoints
        sensitive_endpoints = ["/admin", "/dashboard", "/settings", "/profile"]
        base_url = target["url"]
        
        for endpoint in sensitive_endpoints:
            try:
                response = requests.get(urljoin(base_url, endpoint), timeout=10)
                if response.status_code == 200:
                    findings.append({
                        "issue": "Missing authentication on sensitive endpoint",
                        "details": f"Endpoint {endpoint} accessible without authentication",
                        "severity": "HIGH",
                        "recommendation": "Implement proper authentication for sensitive endpoints"
                    })
            except requests.RequestException:
                continue
        
        # Test for authorization bypass
        if target.get("auth_token"):
            auth_headers = {"Authorization": f"Bearer {target['auth_token']}"}
            
            # Test horizontal privilege escalation
            try:
                # Try to access admin endpoint with regular user token
                response = requests.get(
                    urljoin(base_url, "/admin/users"),
                    headers=auth_headers,
                    timeout=10
                )
                if response.status_code == 200:
                    findings.append({
                        "issue": "Horizontal privilege escalation",
                        "details": "Regular user can access admin functionality",
                        "severity": "CRITICAL",
                        "recommendation": "Implement proper authorization checks"
                    })
            except requests.RequestException:
                pass
        
        return findings
    
    async def test_cryptographic_failures(self, target: Dict) -> List[Dict]:
        """Test for cryptographic failures (A02)"""
        findings = []
        base_url = target["url"]
        
        # Test for weak SSL/TLS configuration
        try:
            response = requests.get(base_url, timeout=10, verify=False)
            if response.url.startswith("http://"):
                findings.append({
                    "issue": "Unencrypted communication",
                    "details": "Application uses HTTP instead of HTTPS",
                    "severity": "HIGH",
                    "recommendation": "Implement HTTPS for all communications"
                })
            
            # Check SSL certificate
            if response.raw and hasattr(response.raw, "peer_cert"):
                cert = response.raw.peer_cert
                if cert:
                    # Check for weak ciphers
                    if hasattr(cert, "cipher_name"):
                        cipher = cert.cipher_name()
                        if "RC4" in cipher or "DES" in cipher or "3DES" in cipher:
                            findings.append({
                                "issue": "Weak cipher suite",
                                "details": f"Using weak cipher: {cipher}",
                                "severity": "MEDIUM",
                                "recommendation": "Use strong cipher suites only"
                            })
        except requests.RequestException:
            pass
        
        # Test for sensitive data in URLs
        sensitive_patterns = [
            r"password=",
            r"token=",
            r"key=",
            r"secret=",
            r"api_key="
        ]
        
        for pattern in sensitive_patterns:
            if re.search(pattern, base_url):
                findings.append({
                    "issue": "Sensitive data in URL",
                    "details": f"URL contains sensitive data pattern: {pattern}",
                    "severity": "MEDIUM",
                    "recommendation": "Avoid passing sensitive data in URLs"
                })
        
        return findings
    
    async def test_injection(self, target: Dict) -> List[Dict]:
        """Test for injection vulnerabilities (A03)"""
        findings = []
        base_url = target["url"]
        
        # Test SQL injection
        sql_payloads = [
            "' OR '1'='1",
            "'; DROP TABLE users; --",
            "1' UNION SELECT password FROM users WHERE '1'='1"
        ]
        
        for payload in sql_payloads:
            try:
                response = requests.post(
                    urljoin(base_url, "/api/search"),
                    json={"query": payload},
                    timeout=10
                )
                if response.status_code == 200 and "error" not in response.text.lower():
                    findings.append({
                        "issue": "Potential SQL injection",
                        "details": f"SQL payload: {payload}",
                        "severity": "CRITICAL",
                        "recommendation": "Use parameterized queries and input validation"
                    })
            except requests.RequestException:
                pass
        
        # Test XSS
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "javascript:alert('XSS')"
        ]
        
        for payload in xss_payloads:
            try:
                response = requests.post(
                    urljoin(base_url, "/api/comment"),
                    json={"comment": payload},
                    timeout=10
                )
                if payload in response.text:
                    findings.append({
                        "issue": "Cross-site scripting (XSS)",
                        "details": f"XSS payload: {payload}",
                        "severity": "HIGH",
                        "recommendation": "Implement proper input validation and output encoding"
                    })
            except requests.RequestException:
                pass
        
        # Test command injection
        cmd_payloads = [
            "; ls -la",
            "| cat /etc/passwd",
            "&& echo 'Command Injection'"
        ]
        
        for payload in cmd_payloads:
            try:
                response = requests.post(
                    urljoin(base_url, "/api/process"),
                    json={"command": payload},
                    timeout=10
                )
                if response.status_code == 200:
                    findings.append({
                        "issue": "Command injection",
                        "details": f"Command payload: {payload}",
                        "severity": "CRITICAL",
                        "recommendation": "Avoid executing system commands from user input"
                    })
            except requests.RequestException:
                pass
        
        return findings
    
    async def test_insecure_design(self, target: Dict) -> List[Dict]:
        """Test for insecure design (A04)"""
        findings = []
        base_url = target["url"]
        
        # Test for CORS misconfiguration
        try:
            response = requests.options(base_url, timeout=10)
            cors_headers = response.headers.get("Access-Control-Allow-Origin", "")
            
            if cors_headers == "*" or cors_headers == "":
                findings.append({
                    "issue": "Permissive CORS policy",
                    "details": f"CORS allows all origins: {cors_headers}",
                    "severity": "MEDIUM",
                    "recommendation": "Restrict CORS to specific origins"
                })
        except requests.RequestException:
            pass
        
        # Test for clickjacking protection
        try:
            response = requests.get(base_url, timeout=10)
            if "X-Frame-Options" not in response.headers:
                findings.append({
                    "issue": "Missing clickjacking protection",
                    "details": "No X-Frame-Options header found",
                    "severity": "MEDIUM",
                    "recommendation": "Implement X-Frame-Options header"
                })
        except requests.RequestException:
            pass
        
        # Test for CSRF protection
        if target.get("auth_token"):
            try:
                response = requests.post(
                    urljoin(base_url, "/api/transfer"),
                    json={"amount": 1000, "to": "attacker"},
                    headers={"Authorization": f"Bearer {target['auth_token']}"},
                    timeout=10
                )
                # Check if CSRF token is required
                if response.status_code == 200:
                    findings.append({
                        "issue": "Missing CSRF protection",
                        "details": "State-changing request without CSRF token",
                        "severity": "HIGH",
                        "recommendation": "Implement CSRF tokens for state-changing operations"
                    })
            except requests.RequestException:
                pass
        
        return findings
    
    async def test_security_misconfiguration(self, target: Dict) -> List[Dict]:
        """Test for security misconfiguration (A05)"""
        findings = []
        base_url = target["url"]
        
        # Test for security headers
        security_headers = [
            "X-Content-Type-Options",
            "X-Frame-Options",
            "X-XSS-Protection",
            "Strict-Transport-Security",
            "Content-Security-Policy"
        ]
        
        try:
            response = requests.get(base_url, timeout=10)
            for header in security_headers:
                if header not in response.headers:
                    findings.append({
                        "issue": f"Missing security header: {header}",
                        "details": f"Header {header} not found in response",
                        "severity": "MEDIUM",
                        "recommendation": f"Implement {header} header"
                    })
        except requests.RequestException:
            pass
        
        # Test for directory listing
        try:
            response = requests.get(urljoin(base_url, "/"), timeout=10)
            if "Index of" in response.text or "Directory Listing" in response.text:
                findings.append({
                    "issue": "Directory listing enabled",
                    "details": "Web server allows directory listing",
                    "severity": "LOW",
                    "recommendation": "Disable directory listing"
                })
        except requests.RequestException:
            pass
        
        # Test for error information disclosure
        try:
            response = requests.get(urljoin(base_url, "/nonexistent"), timeout=10)
            if "stack trace" in response.text.lower() or "error" in response.text.lower():
                findings.append({
                    "issue": "Error information disclosure",
                    "details": "Application exposes detailed error information",
                    "severity": "LOW",
                    "recommendation": "Implement generic error messages"
                })
        except requests.RequestException:
            pass
        
        return findings
    
    async def test_vulnerable_components(self, target: Dict) -> List[Dict]:
        """Test for vulnerable components (A06)"""
        findings = []
        base_url = target["url"]
        
        # Check for outdated software versions
        try:
            response = requests.get(base_url, timeout=10)
            server_header = response.headers.get("Server", "")
            
            vulnerable_servers = {
                "Apache/2.2.15": "Apache 2.2.15 has known vulnerabilities",
                "nginx/1.14.0": "nginx 1.14.0 has known vulnerabilities",
                "IIS/7.0": "IIS 7.0 has known vulnerabilities"
            }
            
            for vulnerable_server, description in vulnerable_servers.items():
                if vulnerable_server in server_header:
                    findings.append({
                        "issue": "Outdated server software",
                        "details": f"Server: {server_header} - {description}",
                        "severity": "HIGH",
                        "recommendation": "Update to latest stable version"
                    })
        except requests.RequestException:
            pass
        
        # Check for vulnerable JavaScript libraries
        try:
            response = requests.get(base_url, timeout=10)
            if "jquery" in response.text:
                # Check for known vulnerable jQuery versions
                vulnerable_jquery = [
                    "jquery-1.12.4",
                    "jquery-2.1.4",
                    "jquery-3.4.1"
                ]
                
                for version in vulnerable_jquery:
                    if version in response.text:
                        findings.append({
                            "issue": "Vulnerable JavaScript library",
                            "details": f"jQuery {version} has known vulnerabilities",
                            "severity": "MEDIUM",
                            "recommendation": "Update jQuery to latest version"
                        })
        except requests.RequestException:
            pass
        
        return findings
    
    async def test_identification_authentication(self, target: Dict) -> List[Dict]:
        """Test for identification and authentication failures (A07)"""
        findings = []
        base_url = target["url"]
        
        # Test for weak password policy
        weak_passwords = ["password", "123456", "admin", "qwerty", "welcome"]
        
        for password in weak_passwords:
            try:
                response = requests.post(
                    urljoin(base_url, "/api/login"),
                    json={"username": "test", "password": password},
                    timeout=10
                )
                if response.status_code == 200:
                    findings.append({
                        "issue": "Weak password policy",
                        "details": f"Weak password accepted: {password}",
                        "severity": "HIGH",
                        "recommendation": "Implement strong password requirements"
                    })
            except requests.RequestException:
                pass
        
        # Test for session management issues
        if target.get("auth_token"):
            try:
                # Test session fixation
                response = requests.get(
                    urljoin(base_url, "/api/profile"),
                    headers={"Authorization": f"Bearer {target['auth_token']}"},
                    timeout=10
                )
                
                # Check if session ID is predictable or reused
                session_headers = response.headers.get("Set-Cookie", "")
                if session_headers and "sessionid=" in session_headers:
                    findings.append({
                        "issue": "Predictable session ID",
                        "details": "Session ID appears to be predictable",
                        "severity": "MEDIUM",
                        "recommendation": "Use cryptographically random session IDs"
                    })
            except requests.RequestException:
                pass
        
        # Test for account lockout
        for i in range(10):
            try:
                response = requests.post(
                    urljoin(base_url, "/api/login"),
                    json={"username": "test", "password": "wrong"},
                    timeout=10
                )
                if i == 9 and response.status_code == 200:
                    findings.append({
                        "issue": "No account lockout mechanism",
                        "details": "10 failed login attempts without lockout",
                        "severity": "HIGH",
                        "recommendation": "Implement account lockout after failed attempts"
                    })
                    break
            except requests.RequestException:
                break
        
        return findings
    
    async def test_software_data_integrity(self, target: Dict) -> List[Dict]:
        """Test for software and data integrity failures (A08)"""
        findings = []
        base_url = target["url"]
        
        # Test for unsigned software downloads
        try:
            response = requests.get(urljoin(base_url, "/downloads"), timeout=10)
            if response.status_code == 200:
                downloads = response.text
                if ".exe" in downloads or ".dmg" in downloads or ".deb" in downloads:
                    findings.append({
                        "issue": "Unsigned software downloads",
                        "details": "Software downloads lack digital signatures",
                        "severity": "MEDIUM",
                        "recommendation": "Provide digitally signed software"
                    })
        except requests.RequestException:
            pass
        
        # Test for insecure data transmission
        try:
            response = requests.get(base_url, timeout=10)
            if response.url.startswith("http://"):
                findings.append({
                    "issue": "Insecure data transmission",
                    "details": "Data transmitted over unencrypted connection",
                    "severity": "HIGH",
                    "recommendation": "Use HTTPS for all data transmission"
                })
        except requests.RequestException:
            pass
        
        return findings
    
    async def test_logging_monitoring(self, target: Dict) -> List[Dict]:
        """Test for logging and monitoring failures (A09)"""
        findings = []
        base_url = target["url"]
        
        # Test for security event logging
        try:
            response = requests.post(
                urljoin(base_url, "/api/admin/delete"),
                json={"id": 1},
                headers={"Authorization": f"Bearer {target.get('auth_token', '')}"},
                timeout=10
            )
            # Check if security event is logged
            try:
                logs_response = requests.get(
                    urljoin(base_url, "/api/logs"),
                    headers={"Authorization": f"Bearer {target.get('auth_token', '')}"},
                    timeout=10
                )
                if response.status_code == 200:
                    logs = response.json()
                    if not any("delete" in log.get("message", "").lower() for log in logs):
                        findings.append({
                            "issue": "Security events not logged",
                            "details": "Admin delete operation not found in logs",
                            "severity": "MEDIUM",
                            "recommendation": "Log all security-relevant events"
                        })
            except requests.RequestException:
                findings.append({
                    "issue": "No logging endpoint available",
                    "details": "Cannot verify logging implementation",
                    "severity": "MEDIUM",
                    "recommendation": "Implement security event logging"
                })
        except requests.RequestException:
            findings.append({
                "issue": "No security monitoring",
                "details": "Cannot verify if security events are monitored",
                "severity": "MEDIUM",
                "recommendation": "Implement security monitoring and logging"
            })
        
        return findings

async def test_ssrf(self, target: Dict) -> List[Dict]:
    """Test for Server-Side Request Forgery (A10)"""
    findings = []
    base_url = target["url"]
    
    # Test for CSRF token validation in state-changing requests
    if target.get("auth_token"):
        try:
            # Test without CSRF token
            response = requests.post(
                urljoin(base_url, "/api/change-password"),
                json={"new_password": "newpass123"},
                headers={"Authorization": f"Bearer {target['auth_token']}"},
                timeout=10
            )
            if response.status_code == 200:
                findings.append({
                    "issue": "Missing CSRF protection",
                    "details": "State-changing request without CSRF token",
                    "severity": "HIGH",
                    "recommendation": "Implement CSRF tokens for state-changing operations"
                })
        except requests.RequestException:
            pass
    
    # Test for referer validation
    try:
        response = requests.post(
            urljoin(base_url, "/api/update-profile"),
            json={"name": "test"},
            headers={
                "Authorization": f"Bearer {target.get('auth_token', '')}",
                "Referer": "http://malicious-site.com"
            },
            timeout=10
        )
        if response.status_code == 200:
            findings.append({
                "issue": "No referer validation",
                "details": "Request accepted from untrusted referer",
                "severity": "MEDIUM",
                "recommendation": "Validate referer header for sensitive operations"
            })
    except requests.RequestException:
        pass
    
    return findings


class WebApplicationSecurityTest(SecurityTest):
    """Web application security test wrapper"""
    
    def __init__(self):
        super().__init__("Web Application Security", "web_application", "HIGH")
        self.web_test = WebApplicationTest("OWASP Top 10", "web_application", "HIGH")
    
    async def run(self, target: Dict) -> Dict[str, Any]:
        """Run web application security test"""
        return await self.web_test.run(target)
