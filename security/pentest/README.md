# SkySentinel Penetration Testing Framework

Comprehensive penetration testing framework for automated security assessments and vulnerability detection.

## Overview

The penetration testing framework provides:
- **Automated Security Testing** - Network, API, container, and web application testing
- **OWASP Top 10 Coverage** - Complete web application vulnerability testing
- **Container Security** - Docker and Kubernetes security assessments
- **Orchestration & Scheduling** - Automated test execution and management
- **Comprehensive Reporting** - HTML, PDF, JSON, and CSV report generation
- **Analytics & Trends** - Vulnerability tracking and trend analysis

## Components

### 1. Main Framework (`pentest_framework.py`)

Core penetration testing framework with multiple test types:

**Test Types:**
- **Network Security Tests** - Port scanning, SSL/TLS testing
- **API Security Tests** - SQL injection, XSS, authentication testing
- **Container Security Tests** - Image scanning, configuration checks
- **Web Application Tests** - OWASP Top 10 vulnerability testing

**Key Features:**
- Asynchronous test execution
- Risk scoring and severity classification
- Comprehensive finding details and recommendations
- Test result aggregation and summary

### 2. Web Application Tests (`web_application_tests.py`)

Complete OWASP Top 10 implementation:

**OWASP Top 10 Coverage:**
- **A01: Broken Access Control** - Authentication and authorization testing
- **A02: Cryptographic Failures** - SSL/TLS and encryption testing
- **A03: Injection** - SQL injection, XSS, command injection
- **A04: Insecure Design** - CORS, CSRF, clickjacking testing
- **A05: Security Misconfiguration** - Headers, directory listing, error disclosure
- **A06: Vulnerable Components** - Outdated software detection
- **A07: Authentication Failures** - Password policies, session management
- **A08: Data Integrity** - Signed software, secure transmission
- **A09: Logging Failures** - Security event logging verification
- **A10: Server-Side Request Forgery** - SSRF testing

### 3. Reporting & Analytics (`reporting.py`)

Comprehensive reporting and analytics system:

**Report Formats:**
- **HTML Reports** - Interactive web-based reports with charts
- **PDF Reports** - Professional PDF documents for stakeholders
- **JSON Reports** - Machine-readable data for integration
- **CSV Reports** - Spreadsheet-compatible data for analysis

**Analytics Features:**
- Vulnerability trend analysis
- Risk scoring and prioritization
- Compliance metrics tracking
- Executive summary generation
- Remediation planning

### 4. Orchestration & Scheduling (`orchestration.py`)

Test orchestration and automation capabilities:

**Scheduling:**
- **Recurring Tests** - Daily, weekly, monthly, quarterly scheduling
- **Continuous Monitoring** - Real-time security monitoring
- **Automated Retesting** - Follow-up testing for remediation
- **Test Templates** - Reusable test configurations

**Automation:**
- **Alert Integration** - Critical finding notifications
- **Dashboard Integration** - Real-time status monitoring
- **External Integrations** - Slack, Jira, DefectDojo, SIEM

## Quick Start

### 1. Basic Penetration Test

```python
import asyncio
from security.pentest.pentest_framework import PenetrationTestingFramework

async def run_pentest():
    framework = PenetrationTestingFramework()
    
    target = {
        "ip": "192.168.1.100",
        "hostname": "example.com",
        "url": "https://app.example.com",
        "endpoint": "https://api.example.com",
        "image": "nginx:latest",
        "container_id": "abc123"
    }
    
    results = await framework.run_full_assessment(target)
    print(f"Risk Score: {results['risk_score']}")
    print(f"Findings: {len(results['recommendations'])}")

asyncio.run(run_pentest())
```

### 2. Web Application Security Test

```python
from security.pentest.web_application_tests import WebApplicationSecurityTest

async def test_web_app():
    test = WebApplicationSecurityTest()
    
    target = {
        "url": "https://app.example.com",
        "auth_token": "your-auth-token"
    }
    
    results = await test.run(target)
    for finding in results["findings"]:
        print(f"{finding['severity']}: {finding['issue']}")
```

### 3. Scheduled Testing

```python
from security.pentest.orchestration import PentestManager

manager = PentestManager()
manager.start()

# Schedule recurring assessment
test_id = manager.schedule_recurring_assessment(
    target={"url": "https://app.example.com"},
    schedule="weekly"
)

print(f"Scheduled test ID: {test_id}")
```

## Configuration

### Target Configuration

```python
target = {
    # Network testing
    "ip": "192.168.1.100",
    "hostname": "example.com",
    
    # Web application testing
    "url": "https://app.example.com",
    "auth_token": "your-auth-token",
    
    # API testing
    "endpoint": "https://api.example.com",
    
    # Container testing
    "image": "nginx:latest",
    "container_id": "abc123"
}
```

### Test Scheduling

```python
test_config = {
    "name": "Weekly Security Assessment",
    "test_type": "full_assessment",
    "target": target,
    "schedule": "weekly",  # daily, weekly, monthly, quarterly
    "enabled": True
}
```

### Report Generation

```python
from security.pentest.reporting import PentestReportGenerator

generator = PentestReportGenerator()

# Generate HTML report
html_report = generator.generate_html_report(results)

# Generate PDF report
pdf_report = generator.generate_pdf_report(results)

# Generate JSON report
json_report = generator.generate_json_report(results)

# Export to file
filename = generator.export_report(results, "html", "security_report.html")
```

## Test Types

### Network Security Tests

**Capabilities:**
- Port scanning with nmap
- SSL/TLS configuration testing
- Service enumeration
- Network vulnerability assessment

**Example Findings:**
- Open ports detection
- Weak SSL/TLS ciphers
- Outdated service versions
- Network misconfigurations

### API Security Tests

**Capabilities:**
- SQL injection testing
- Cross-site scripting (XSS)
- Authentication bypass testing
- Rate limiting verification
- Input validation testing

**Example Findings:**
- SQL injection vulnerabilities
- XSS vulnerabilities
- Default credentials
- Weak authentication
- Missing rate limiting

### Container Security Tests

**Capabilities:**
- Container image vulnerability scanning
- Configuration security checks
- Runtime security assessment
- Dockerfile analysis

**Example Findings:**
- Vulnerable container images
- Running as root user
- Privileged mode containers
- Insecure mount points

### Web Application Tests

**Capabilities:**
- OWASP Top 10 testing
- Authentication and authorization testing
- Session management testing
- Input validation testing
- Security header verification

**Example Findings:**
- Broken access control
- Cryptographic failures
- Injection vulnerabilities
- Security misconfigurations
- Vulnerable components

## Reporting

### Executive Summary

```python
summary = generator.generate_executive_summary(results)
print(f"Risk Level: {summary['risk_level']}")
print(f"Total Findings: {summary['total_findings']}")
print(f"Critical Issues: {summary['critical_findings']}")
```

### Detailed Reports

**HTML Reports:**
- Interactive web interface
- Charts and visualizations
- Detailed findings with recommendations
- Severity-based color coding

**PDF Reports:**
- Professional formatting
- Executive summary
- Detailed technical findings
- Remediation recommendations

### Analytics

```python
from security.pentest.reporting import PentestAnalytics

analytics = PentestAnalytics()
analytics.add_test_result(results)

# Get vulnerability trends
trends = analytics.get_vulnerability_trends()

# Get most common vulnerabilities
common_vulns = analytics.get_most_common_vulnerabilities(limit=10)

# Get test statistics
stats = analytics.get_test_statistics()
```

## Orchestration

### Scheduled Testing

```python
from security.pentest.orchestration import PentestOrchestrator

orchestrator = PentestOrchestrator()
orchestrator.start_scheduler()

# Add scheduled test
test_id = orchestrator.add_scheduled_test({
    "name": "Daily Network Scan",
    "test_type": "network",
    "target": {"ip": "192.168.1.100"},
    "schedule": "daily",
    "enabled": True
})

# Get upcoming tests
upcoming = orchestrator.get_upcoming_tests(hours=24)
```

### Continuous Monitoring

```python
from security.pentest.orchestration import PentestAutomation

automation = PentestAutomation(orchestrator)

# Start continuous monitoring
monitoring_id = await automation.run_continuous_monitoring(
    target={"url": "https://app.example.com"},
    interval_minutes=60
)
```

### Automated Retesting

```python
# Schedule automated retesting
retest_id = await automation.run_automated_retesting(
    test_id="test_20240123_143000",
    interval_days=7
)
```

## Integrations

### Slack Integration

```python
from security.pentest.orchestration import PentestIntegrations

integrations = PentestIntegrations(orchestrator)
integrations.integrate_with_slack("https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK")
```

### Jira Integration

```python
jira_config = {
    "url": "https://your-domain.atlassian.net",
    "username": "your-email@company.com",
    "api_token": "your-api-token",
    "project": "SEC"
}

integrations.integrate_with_jira(jira_config)
```

### DefectDojo Integration

```python
dojo_config = {
    "url": "https://defectdojo.example.com",
    "api_key": "your-api-key",
    "product": "SkySentinel"
}

integrations.integrate_with_defectdojo(dojo_config)
```

## Dashboard

### Real-time Monitoring

```python
from security.pentest.orchestration import PentestDashboard

dashboard = PentestDashboard(orchestrator)

# Get dashboard data
dashboard_data = dashboard.get_dashboard_data()

# Get vulnerability heatmap
heatmap = dashboard.get_vulnerability_heatmap()

# Get compliance metrics
compliance = dashboard.get_compliance_metrics()
```

### Key Metrics

- **Risk Score**: Overall security risk (0-100)
- **Findings by Severity**: Critical, High, Medium, Low counts
- **Test Success Rate**: Percentage of tests passing
- **Vulnerability Trends**: Changes over time
- **Remediation Progress**: Issues resolved vs. open

## Best Practices

### 1. Regular Testing

- **Daily**: Automated security monitoring
- **Weekly**: Web application security tests
- **Monthly**: Container security scans
- **Quarterly**: Full penetration assessments

### 2. Risk Prioritization

1. **Critical**: Immediate remediation (24 hours)
2. **High**: Within 1 week
3. **Medium**: Within 1 month
4. **Low**: Next assessment cycle

### 3. Reporting

- Generate executive summaries for management
- Create detailed technical reports for developers
- Track trends and improvements over time
- Document remediation efforts

### 4. Integration

- Integrate with CI/CD pipelines
- Connect to ticketing systems
- Set up alert notifications
- Automate remediation workflows

## Troubleshooting

### Common Issues

1. **Test Execution Failures**
   - Check target accessibility
   - Verify network connectivity
   - Review authentication credentials

2. **Tool Dependencies**
   - Install required tools (nmap, testssl.sh, trivy)
   - Verify tool configurations
   - Check tool versions

3. **Report Generation**
   - Verify Jinja2 installation
   - Check PDF generation dependencies
   - Review template configurations

### Debug Mode

```python
import logging
logging.basicConfig(level=logging.DEBUG)
```

## Security Considerations

### Test Authorization

- Ensure proper authorization before testing
- Document test scope and limitations
- Get written permission for external testing
- Respect rate limits and service availability

### Data Protection

- Secure storage of test results
- Encrypt sensitive findings
- Limit access to vulnerability data
- Follow data retention policies

### Ethical Guidelines

- Test only authorized targets
- Avoid production disruption
- Report findings responsibly
- Follow disclosure policies

## Performance Optimization

### Parallel Execution

```python
# Tests run concurrently by default
# Configure concurrency limits if needed
```

### Caching

- Cache test results for unchanged targets
- Implement smart re-testing logic
- Optimize report generation
- Use efficient data structures

### Resource Management

- Monitor memory usage
- Limit concurrent test execution
- Implement timeout handling
- Clean up resources properly

## Extending the Framework

### Custom Tests

```python
from security.pentest.pentest_framework import SecurityTest

class CustomSecurityTest(SecurityTest):
    async def run(self, target: Dict) -> Dict[str, Any]:
        # Implement custom test logic
        return results
```

### New Report Formats

```python
# Extend report generator with custom formats
def generate_custom_report(self, results: Dict) -> str:
    # Implement custom report format
    return report_content
```

### Additional Integrations

```python
# Add new integration classes
class CustomIntegration:
    def __init__(self, orchestrator):
        self.orchestrator = orchestrator
    
    def integrate_with_service(self, config):
        # Implement integration logic
        pass
```

## Support

### Documentation

- API documentation available
- Code examples and tutorials
- Best practices guide
- Troubleshooting guide

### Community

- GitHub issues for bug reports
- Feature requests and discussions
- Contribution guidelines
- Security vulnerability reporting

## License

This penetration testing framework is part of SkySentinel and follows the project's licensing terms.

## Version History

- **v1.0**: Initial release with basic testing capabilities
- **v1.1**: Added web application testing and OWASP Top 10
- **v1.2**: Enhanced reporting and analytics
- **v1.3**: Added orchestration and scheduling
- **v1.4**: Improved integrations and dashboard
