import asyncio
from typing import Dict, List, Any, Optional
from datetime import datetime, timedelta
import json
from dataclasses import dataclass
from enum import Enum
import schedule
import threading
import time

class TestStatus(Enum):
    """Test status enumeration"""
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"

@dataclass
class ScheduledTest:
    """Scheduled test configuration"""
    id: str
    name: str
    test_type: str
    target: Dict[str, Any]
    schedule: str
    enabled: bool
    last_run: Optional[datetime] = None
    next_run: Optional[datetime] = None
    status: TestStatus = TestStatus.PENDING
    results: Optional[Dict[str, Any]] = None

class PentestOrchestrator:
    """Orchestrate and schedule penetration tests"""
    
    def __init__(self):
        self.scheduled_tests = []
        self.running_tests = {}
        self.test_history = []
        self.scheduler_thread = None
        self.is_running = False
    
    def add_scheduled_test(self, test_config: Dict) -> str:
        """Add a scheduled test"""
        test_id = f"test_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}"
        
        scheduled_test = ScheduledTest(
            id=test_id,
            name=test_config.get("name", "Unnamed Test"),
            test_type=test_config.get("test_type", "network"),
            target=test_config.get("target", {}),
            schedule=test_config.get("schedule", "daily"),
            enabled=test_config.get("enabled", True),
            next_run=self._calculate_next_run(test_config.get("schedule", "daily"))
        )
        
        self.scheduled_tests.append(scheduled_test)
        
        # Schedule the test
        schedule.every(
            scheduled_test.schedule,
            self._run_scheduled_test,
            args=[test_id]
        ).tag(test_id)
        
        return test_id
    
    def remove_scheduled_test(self, test_id: str) -> bool:
        """Remove a scheduled test"""
        self.scheduled_tests = [t for t in self.scheduled_tests if t.id != test_id]
        schedule.cancel_job(test_id)
        return True
    
    def run_test_now(self, test_id: str) -> Dict[str, Any]:
        """Run a test immediately"""
        test = self._find_scheduled_test(test_id)
        if not test:
            raise ValueError(f"Test not found: {test_id}")
        
        return asyncio.run(self._run_scheduled_test(test_id))
    
    def get_scheduled_tests(self) -> List[ScheduledTest]:
        """Get all scheduled tests"""
        return self.scheduled_tests
    
    def get_test_history(self, limit: int = 50) -> List[Dict[str, Any]]:
        """Get test history"""
        return self.test_history[:limit]
    
    def start_scheduler(self):
        """Start the scheduler thread"""
        if not self.is_running:
            self.is_running = True
            self.scheduler_thread = threading.Thread(target=self._scheduler_loop)
            self.scheduler_thread.daemon = True
            self.scheduler_thread.start()
    
    def stop_scheduler(self):
        """Stop the scheduler thread"""
        self.is_running = False
        if self.scheduler_thread:
            self.scheduler_thread.join()
    
    def _scheduler_loop(self):
        """Main scheduler loop"""
        while self.is_running:
            try:
                schedule.run_pending()
                time.sleep(60)  # Check every minute
            except Exception as e:
                print(f"Scheduler error: {e}")
                time.sleep(60)
    
    async def _run_scheduled_test(self, test_id: str) -> Dict[str, Any]:
        """Run a scheduled test"""
        test = self._find_scheduled_test(test_id)
        if not test:
            return {"error": f"Test not found: {test_id}"}
        
        if test.status in [TestStatus.RUNNING]:
            return {"error": f"Test already running: {test_id}"}
        
        try:
            test.status = TestStatus.RUNNING
            test.last_run = datetime.utcnow()
            
            # Import and run the appropriate test
            if test.test_type == "network":
                from .pentest_framework import NetworkSecurityTest
                test_instance = NetworkSecurityTest(test.name, test.category, test.severity)
            elif test.test_type == "api":
                from .pentest_framework import APISecurityTest
                test_instance = APISecurityTest(test.name, test.category, test.security)
            elif test.test_type == "container":
                from .pentest_framework import ContainerSecurityTest
                test_instance = ContainerSecurityTest(test.name, test.category, test.severity)
            elif test.test_type == "web_application":
                from .web_application_tests import WebApplicationSecurityTest
                test_instance = WebApplicationSecurityTest(test.name, test.category, test.severity)
            else:
                from .pentest_framework import SecurityTest
                test_instance = SecurityTest(test.name, test.category, test.severity)
            
            results = await test_instance.run(test.target)
            test.results = results
            test.status = TestStatus.COMPLETED if results.get("findings") else TestStatus.FAILED
            test.next_run = self._calculate_next_run(test.schedule)
            
            # Add to history
            self.test_history.append({
                "test_id": test_id,
                "name": test.name,
                "test_type": test.test_type,
                "target": test.target,
                "timestamp": datetime.utcnow().isoformat(),
                "status": test.status.value,
                "results": results,
                "duration": results.get("duration", 0)
            })
            
            return results
            
        except Exception as e:
            test.status = TestStatus.FAILED
            return {"error": f"Test failed: {str(e)}}
        finally:
            test.status = TestStatus.COMPLETED
    
    def _find_scheduled_test(self, test_id: str) -> Optional[ScheduledTest]:
        """Find a scheduled test by ID"""
        for test in self.scheduled_tests:
            if test.id == test_id:
                return test
        return None
    
    def _calculate_next_run(self, schedule: str) -> datetime:
        """Calculate next run time based on schedule"""
        now = datetime.utcnow()
        
        if schedule == "daily":
            return now + timedelta(days=1)
        elif schedule == "weekly":
            return now + timedelta(weeks=1)
        elif schedule == "monthly":
            return now + timedelta(days=30)
        elif schedule == "quarterly":
            return now + timedelta(days=90)
        elif schedule.startswith("every "):
            # Parse "every X hours/days/weeks"
            parts = schedule.split(" ")
            if len(parts) >= 2:
                try:
                    value = int(parts[1])
                    unit = parts[2]
                    
                    if unit.startswith("hour"):
                        return now + timedelta(hours=value)
                    elif unit.startswith("day"):
                        return now + timedelta(days=value)
                    elif unit.startswith("week"):
                        return now + timedelta(weeks=value)
                    elif unit.startswith("month"):
                        return now + timedelta(months=value)
                except ValueError:
                    pass
        
        return now + timedelta(days=1)  # Default to daily
    
    def get_upcoming_tests(self, hours: int = 24) -> List[ScheduledTest]:
        """Get tests scheduled in the next N hours"""
        now = datetime.utcnow()
        upcoming = []
        
        for test in self.scheduled_tests:
            if test.enabled and test.next_run and test.next_run <= now + timedelta(hours=hours):
                upcoming.append(test)
        
        return sorted(upcoming, key=lambda x: x.next_run)
    
    def get_overdue_tests(self) -> List[ScheduledTest]:
        """Get tests that are overdue"""
        now = datetime.utcnow()
        overdue = []
        
        for test in self.scheduled_tests:
            if test.enabled and test.next_run and test.next_run < now:
                overdue.append(test)
        
        return sorted(overdue, key=lambda x: x.next_run)
    
    def generate_test_schedule_report(self) -> Dict[str, Any]:
        """Generate test schedule report"""
        now = datetime.utcnow()
        
        return {
            "generated_at": now.isoformat(),
            "total_tests": len(self.scheduled_tests),
            "enabled_tests": len([t for t in self.scheduler if t.enabled]),
            "upcoming_tests": self.get_upcoming_tests(),
            "overdue_tests": self.get_overdue_tests(),
            "scheduler_running": self.is_running,
            "test_history_size": len(self.test_history)
        }


class PentestAutomation:
    """Automation capabilities for penetration testing"""
    
    def __init__(self, orchestrator: PentestOrchestrator):
        self.orchestrator = orchestrator
    
    async def run_continuous_monitoring(self, target: Dict, interval_minutes: int = 60) -> str:
        """Run continuous monitoring"""
        monitoring_id = f"continuous_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}"
        
        # Create monitoring task
        task = asyncio.create_task(
            self._continuous_monitoring_loop(target, interval_minutes, monitoring_id)
        )
        
        return monitoring_id
    
    async def _continuous_monitoring_loop(self, target: Dict, interval_minutes: int, monitoring_id: str):
        """Continuous monitoring loop"""
        while True:
            try:
                # Run quick security scan
                from .pentest_framework import NetworkSecurityTest
                quick_test = NetworkSecurityTest("Quick Scan", "network", "MEDIUM")
                results = await quick_test.run(target)
                
                # Check for new critical findings
                critical_findings = [
                    f for finding in results.get("findings", [])
                    if finding["severity"] == "CRITICAL"
                ]
                
                if critical_findings:
                    # Send immediate alert
                    await self._send_critical_alert(target, critical_findings)
                
                # Wait for next iteration
                await asyncio.sleep(interval_minutes * 60)
                
            except Exception as e:
                print(f"Monitoring error: {e}")
                await asyncio.sleep(interval_minutes * 60)
    
    async def _send_critical_alert(self, target: Dict, findings: List[Dict]):
        """Send critical alert"""
        alert_message = f"ðŸš¨ CRITICAL: {len(findings)} critical findings detected for {target}"
        
        # This would integrate with notification service
        print(alert_message)
    
    async def run_automated_retesting(self, test_id: str, interval_days: int = 7) -> str:
        """Automated retesting of failed tests"""
        test = self.orchestrator._find_scheduled_test(test_id)
        if not test:
            raise ValueError(f"Test not found: {test_id}")
        
        # Schedule automated retesting
        retest_id = f"retest_{test_id}_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}"
        
        # Create retest schedule
        schedule.every(interval_days * 24 * 3600, self._automated_retest_loop, args=[test_id, retest_id]).tag(retest_id)
        
        return retest_id
    
    async def _automated_retest_loop(self, test_id: str, retest_id: str):
        """Automated retesting loop"""
        test = self.orchestrator._find_scheduled_test(test_id)
        if not test:
            return
        
        try:
            # Re-run the test
            results = await self.orchestrator._run_scheduled_test(test_id)
            
            # Check if issues are resolved
            previous_findings = test.results.get("findings", [])
            current_findings = results.get("findings", [])
            
            resolved_issues = len(previous_findings) - len(current_findings)
            
            if resolved_issues > 0:
                print(f"âœ… Resolved {resolved_issues} issues in retest")
            
            # Update test status
            test.results = results
            test.status = TestStatus.COMPLETED
            
        except Exception as e:
            print(f"Retest failed: {e}")
    
    def create_test_template(self, test_config: Dict) -> Dict:
        """Create reusable test template"""
        return {
            "name": test_config.get("name", "Custom Test"),
            "test_type": test_config.get("test_type", "custom"),
            "target_template": test_config.get("target_template"),
            "test_config": test_config,
            "default_schedule": test_config.get("default_schedule", "weekly"),
            "enabled": test_config.get("enabled", True)
        }
    
    def clone_test(self, test_id: str, new_name: str) -> str:
        """Clone an existing test"""
        original_test = self.orchestrator._find_scheduled_test(test_id)
        if not original_test:
            raise ValueError(f"Test not found: {test_id}")
        
        # Create cloned test
        cloned_config = {
            "name": new_name,
            "test_type": original_test.test_type,
            "target": original_test.target,
            "schedule": original_test.schedule,
            "enabled": original_test.enabled
        }
        
        return self.add_scheduled_test(cloned_config)


class PentestDashboard:
    """Dashboard for penetration testing results"""
    
    def __init__(self, orchestrator: PentestOrchestrator):
        self.orchestrator = orchestrator
        self.analytics = PentestAnalytics()
    
    def get_dashboard_data(self) -> Dict[str, Any]:
        """Get dashboard data"""
        if not self.orchestrator.test_history:
            return {"error": "No test data available"}
        
        latest_results = self.orchestrator.test_history[-1] if self.orchestrator.test_history else None
        
        return {
            "latest_test": latest_results,
            "test_statistics": self.analytics.get_test_statistics(),
            "vulnerability_trends": self.analytics.get_vulnerability_trends(),
            "upcoming_tests": self.orchestrator.get_upcoming_tests(),
            "overdue_tests": self.orchestrator.get_overdue_tests(),
            "schedule_report": self.orchestrator.generate_test_schedule_report()
        }
    
    def get_vulnerability_heatmap(self) -> Dict[str, Any]:
        """Generate vulnerability heatmap data"""
        trends = self.analytics.get_vulnerability_trends()
        
        heatmap_data = {}
        for issue, data in trends.items():
            heatmap_data[issue] = {
                "occurrences": data["occurrences"],
                "severity": data["severity"],
                "last_seen": data["last_seen"],
                "trend": "increasing" if data["occurrences"] > 1 else "stable"
            }
        
        return heatmap_data
    
    def get_compliance_metrics(self) -> Dict[str, Any]:
        """Get compliance metrics"""
        if not self.orchestrator.test_history:
            return {"error": "No test data available"}
        
        total_tests = len(self.orchestrator.test_history)
        passed_tests = sum(
            1 for test in self.orchestrator.test_history
            if test.get("status") == "completed" and not test.get("findings")
        )
        
        return {
            "total_tests": total_tests,
            "passed_tests": passed_tests,
            "failed_tests": total_tests - passed_tests,
            "success_rate": (passed_tests / total_tests * 100) if total_tests > 0 else 0
        }


class PentestIntegrations:
    """Integration with external systems"""
    
    def __init__(self, orchestrator: PentestOrchestrator):
        self.orchestrator = orchestrator
    
    def integrate_with_slack(self, webhook_url: str) -> bool:
        """Integrate with Slack for notifications"""
        # This would set up Slack webhook integration
        self.slack_webhook_url = webhook_url
        return True
    
    def integrate_with_jira(self, jira_config: Dict) -> bool:
        """Integrate with Jira for issue tracking"""
        # This would set up Jira integration
        self.jira_config = jira_config
        return True
    
    def integrate_with_defectdojo(self, dojo_config: Dict) -> bool:
        """Integrate with DefectDojo for vulnerability tracking"""
        # This would set up DefectDojo integration
        self.dojo_config = dojo_config
        return True
    
    def integrate_with_siem(self, siem_config: Dict) -> bool:
        """Integrate with SIEM for threat intelligence"""
        # This would set up SIEM integration
        self.siem_config = siem_config
        return True


class PentestManager:
    """Main penetration testing manager"""
    
    def __init__(self):
        self.orchestrator = PenetrationTestingFramework()
        self.orchestrator.add_test(WebApplicationSecurityTest("Web Application Security", "web_application", "HIGH"))
        self.orchestrator.add_test(NetworkSecurityTest("Network Security", "network", "HIGH"))
        self.orchestrator.add_test(APISecurityTest("API Security", "api", "HIGH"))
        self.orchestrator.add_test(ContainerSecurityTest("Container Security", "container", "HIGH"))
        
        self.dashboard = PentestDashboard(self.orchestrator)
        self.analytics = PentestAnalytics(self.orchestrator)
        self.integrations = PentestIntegrations(self.orchestrator)
        
        self.orchestrator.add_test(WebApplicationSecurityTest("Web Application Security", "web_application", "HIGH"))
        self.orchestrator.add_test(NetworkSecurityTest("Network Security", "network", "HIGH"))
        self.orchestrator.add_test(APISecurityTest(" "API Security", "api", "HIGH"))
        self.orchestrator.add_test(ContainerSecurityTest("Container Security", "container", "HIGH"))
    
    def start(self):
        """Start the penetration testing service"""
        self.orchestrator.start_scheduler()
        print("ðŸ” SkySentinel Penetration Testing Framework started")
    
    def stop(self):
        """Stop the penetration testing service"""
        self.orchestrator.stop_scheduler()
        print("ðŸ›‘ SkySentinel Penetration Testing Framework stopped")
    
    async def run_assessment(self, target: Dict) -> Dict[str, Any]:
        """Run a full penetration test assessment"""
        return await self.orchestrator.run_full_assessment(target)
    
    def get_dashboard(self) -> Dict[str, Any]:
        """Get dashboard data"""
        return self.dashboard.get_dashboard_data()
    
    def schedule_recurring_assessment(self, target: Dict, schedule: str = "quarterly") -> str:
        """Schedule recurring penetration test"""
        test_config = {
            "name": f"Recurring Test - {target.get('name', 'Target Assessment')}",
            "test_type": "full_assessment",
            "target": target,
            "schedule": schedule,
            "enabled": True
        }
        
        return self.orchestrator.add_scheduled_test(test_config)
